    /*
void storeShadowPolygons(tree shadowPolygons, void* vertexArray, dynamicList segmentsList, double xMeteor, double yMeteor) {
    puts("==================================SHADOWS==================================");
    point_t* auxVertex = vertexArray;
    point_t* extremes = calloc(4, sizeof(point_t));
    int count = 0;
    double biggestX = 0;
    double biggestY = 0;
    for (int i = 0; i < getSize(segmentsList) * 2; i += 2) {
        if (!strcmp(auxVertex[i].code, "RE")) {
            extremes[count] = auxVertex[i];
            if (extremes[count].x > biggestX) {
                biggestX = extremes[count].x;
            }
            if (extremes[count].y > biggestY) {
                biggestY = extremes[count].y;
            }
            count++;
        }
    }

    // printf("Biggest x = %.2lf Biggest y = %.2lf\n", biggestX, biggestY);
    // count = 0;
    // for(int i  = 0; i < 2 * getSize(segmentsList); i++){
    //     if(strcmp(auxVertex[i].code, "RE") && strcmp(auxVertex[i].code, "DIV")){
    //         printf("\naux[%d]: (%.2lf, %.2lf) angle = %.2lf add = %p pair = %p code = %s\n", count, auxVertex[i].x, auxVertex[i].y, auxVertex[i].angle, &auxVertex[i], auxVertex[i].pair, auxVertex[i].code);
    //         count++;
    //     }
    // }

    for (int i = 0; i < getSize(segmentsList) * 2; i++) {
        if (strcmp(auxVertex[i].code, "RE") && strcmp(auxVertex[i].code, "DIV") && strcmp(getCode(auxVertex[i].pair), "RE") && strcmp(getCode(auxVertex[i].pair), "DIV")) {
            dynamicList listOfSegmentsShadowPolygon = createList();
            segment_t* segment = calloc(1, sizeof(segment_t));

            int horizontal = 0;
            int vertical = 0;

            if (auxVertex[i].y == getPointY(auxVertex[i].pair)) {  // the 2 points are horizontal

                
                // Considering points :

                //     p1 ----------------------- p2
            
            

                horizontal = 1;

            } else if (auxVertex[i].x == getPointX(auxVertex[i].pair)) {  // the 2 points vertical

                
                // Considering points :

                //     p1
                //     |
                //     |
                //     |
                //     |
                //     p2
            
            

                vertical = 1;
            }

            if (vertical) {
                if (auxVertex[i].y < getPointY(auxVertex[i].pair)) {
                    segment->point1 = calloc(1, sizeof(point_t));
                    *(segment->point1) = auxVertex[i];
                    segment->point2 = auxVertex[i].pair;
                } else {
                    segment->point2 = calloc(1, sizeof(point_t));
                    segment->point1 = auxVertex[i].pair;
                    *(segment->point2) = auxVertex[i];
                }
            } else if (horizontal) {
                if (auxVertex[i].x < getPointX(auxVertex[i].pair)) {
                    segment->point1 = calloc(1, sizeof(point_t));
                    *(segment->point1) = auxVertex[i];
                    segment->point2 = auxVertex[i].pair;
                } else {
                    segment->point2 = calloc(1, sizeof(point_t));
                    segment->point1 = auxVertex[i].pair;
                    *(segment->point2) = auxVertex[i];
                }
            }
            
            int ok = 0;

            printf("Analizando segmento (%.2lf, %.2lf) - (%.2lf, %.2lf) tipo = %s\n", segment->point1->x, segment->point1->y, segment->point2->x, segment->point2->y, vertical == 1 ? "vertical" : "horizontal");

            segment_t* wallPointSegPoint1 = calloc(1, sizeof(segment_t));
            

            if (strcmp(segment->point1->code, "RE") && strcmp(segment->point1->code, "DIV")) {
                // printf("\nsegment->point1: (%.2lf, %.2lf) angle = %.2lf code = %s type = %c\n", segment->point1->x, segment->point1->y, segment->point1->angle, segment->point1->code, segment->point1->type);
                if ((segment->point1->angle >= 0 && segment->point1->angle < extremes[0].angle) || (segment->point1->angle >= extremes[3].angle && segment->point1->angle < 360)) {
                    //From (segment->point1->x, segment->point1->y) to (biggestX, dist)
                    double dist = (((segment->point1->y - yMeteor) / (segment->point1->x - xMeteor)) * (biggestX - segment->point1->x)) + segment->point1->y;
                    wallPointSegPoint1->point1 = segment->point1;
                    wallPointSegPoint1->point2 = calloc(1, sizeof(point_t));
                    wallPointSegPoint1->point2->x = biggestX;
                    wallPointSegPoint1->point2->y = dist;

                } else if (segment->point1->angle >= extremes[0].angle && segment->point1->angle < extremes[1].angle) {
                    //From (segment->point1->x, segment->point1->y) to (dist, biggestY)
                    double dist = ((biggestY - segment->point1->y) / ((segment->point1->y - yMeteor) / (segment->point1->x - xMeteor))) + segment->point1->x;
                    wallPointSegPoint1->point1 = segment->point1;
                    wallPointSegPoint1->point2 = calloc(1, sizeof(point_t));
                    wallPointSegPoint1->point2->x = dist;
                    wallPointSegPoint1->point2->y = biggestY;

                } else if (segment->point1->angle >= extremes[1].angle && segment->point1->angle < extremes[2].angle) {
                    //From (segment->point1->x, segment->point1->y) to (0.0, dist)
                    double dist = (((segment->point1->y - yMeteor) / (segment->point1->x - xMeteor)) * (0 - segment->point1->x)) + segment->point1->y;
                    wallPointSegPoint1->point1 = segment->point1;
                    wallPointSegPoint1->point2 = calloc(1, sizeof(point_t));
                    wallPointSegPoint1->point2->x = 0.0;
                    wallPointSegPoint1->point2->y = dist;

                } else if (segment->point1->angle >= extremes[2].angle && segment->point1->angle < extremes[3].angle) {
                    //From (segment->point1->x, segment->point1->y) to (dist, 0.0)
                    double dist = ((0 - segment->point1->y) / ((segment->point1->y - yMeteor) / (segment->point1->x - xMeteor))) + segment->point1->x;
                    wallPointSegPoint1->point1 = segment->point1;
                    wallPointSegPoint1->point2 = calloc(1, sizeof(point_t));
                    wallPointSegPoint1->point2->x = dist;
                    wallPointSegPoint1->point2->y = 0.0;
                }
            }

            segment_t* wallPointSegPoint2 = calloc(1, sizeof(segment_t));
        
            printf("%.2lf\n", segment->point2->angle);

            if (strcmp(segment->point2->code, "RE") && strcmp(segment->point2->code, "DIV")) {
                // printf("\nsegment->point2: (%.2lf, %.2lf) angle = %.2lf code = %s type = %c\n", segment->point2->x, segment->point2->y, segment->point2->angle, segment->point2->code, segment->point2->type);
                if ((segment->point2->angle >= 0 && segment->point2->angle < extremes[0].angle) || (segment->point2->angle >= extremes[3].angle && segment->point2->angle < 360)) {
                    //From (segment->point2->x, segment->point2->y) to (biggestX, dist)
                    double dist = (((segment->point2->y - yMeteor) / (segment->point2->x - xMeteor)) * (biggestX - segment->point2->x)) + segment->point2->y;
                    wallPointSegPoint2->point1 = segment->point2;
                    wallPointSegPoint2->point2 = calloc(1, sizeof(point_t));
                    wallPointSegPoint2->point2->x = biggestX;
                    wallPointSegPoint2->point2->y = dist;
                    puts("primeiro");

                } else if (segment->point2->angle >= extremes[0].angle && segment->point2->angle < extremes[1].angle) {
                    //From (segment->point2->x, segment->point2->y) to (dist, biggestY)
                    double dist = ((biggestY - segment->point2->y) / ((segment->point2->y - yMeteor) / (segment->point2->x - xMeteor))) + segment->point2->x;
                    wallPointSegPoint2->point1 = segment->point2;
                    wallPointSegPoint2->point2 = calloc(1, sizeof(point_t));
                    wallPointSegPoint2->point2->x = dist;
                    wallPointSegPoint2->point2->y = biggestY;
                    puts("segundo");

                } else if (segment->point2->angle >= extremes[1].angle && segment->point2->angle < extremes[2].angle) {
                    //From (segment->point2->x, segment->point2->y) to (0.0, dist)
                    double dist = (((segment->point2->y - yMeteor) / (segment->point2->x - xMeteor)) * (0 - segment->point2->x)) + segment->point2->y;
                    wallPointSegPoint2->point1 = segment->point2;
                    wallPointSegPoint2->point2 = calloc(1, sizeof(point_t));
                    wallPointSegPoint2->point2->x = 0.0;
                    wallPointSegPoint2->point2->y = dist;
                    puts("terceiro");

                } else if (segment->point2->angle >= extremes[2].angle && segment->point2->angle < extremes[3].angle) {
                    //From (segment->point2->x, segment->point2->y) to (dist, 0.0)
                    double dist = ((0 - segment->point2->y) / ((segment->point2->y - yMeteor) / (segment->point2->x - xMeteor))) + segment->point2->x;
                    wallPointSegPoint2->point1 = segment->point2;
                    wallPointSegPoint2->point2 = calloc(1, sizeof(point_t));
                    wallPointSegPoint2->point2->x = dist;
                    wallPointSegPoint2->point2->y = 0.0;
                    puts("quarto");
                }
            }
            
            printf("wallpointseg1->p2 = (%.2lf, %.2lf) wallpointseg2->p2 = (%.2lf, %.2lf)\n", wallPointSegPoint1->point2->x, wallPointSegPoint1->point2->y, wallPointSegPoint2->point2->x, wallPointSegPoint2->point2->y);

            if (segment->point1->x < xMeteor && vertical) {  //The segment is on the left of the bomb and vertical

                if (wallPointSegPoint1->point2->x == 0) {
                    if (wallPointSegPoint2->point2->x == 0 && wallPointSegPoint2->point2->y <= biggestY) {  //Need to add only one more segment
                        puts("One");
                        ok = 1;
                        segment_t* newLeftSegment = calloc(1, sizeof(segment_t));
                        newLeftSegment->point1 = calloc(1, sizeof(point_t));
                        newLeftSegment->point2 = calloc(1, sizeof(point_t));

                        newLeftSegment->point1->x = 0.0;
                        newLeftSegment->point1->y = wallPointSegPoint1->point2->y;
                        newLeftSegment->point2->x = 0.0;
                        newLeftSegment->point2->y = wallPointSegPoint2->point2->y;

                        insert(listOfSegmentsShadowPolygon, segment);
                        insert(listOfSegmentsShadowPolygon, wallPointSegPoint1);
                        insert(listOfSegmentsShadowPolygon, wallPointSegPoint2);
                        insert(listOfSegmentsShadowPolygon, newLeftSegment);


                    } else if (wallPointSegPoint2->point2->x > 0 && wallPointSegPoint2->point2->y == biggestY && wallPointSegPoint1->point2->y < biggestY) {
                        puts("two");
                        ok = 1;
                        segment_t* newLeftSegment = calloc(1, sizeof(segment_t));
                        newLeftSegment->point1 = calloc(1, sizeof(point_t));
                        newLeftSegment->point2 = calloc(1, sizeof(point_t));

                        newLeftSegment->point1->x = 0.0;
                        newLeftSegment->point1->y = wallPointSegPoint1->point2->y;
                        newLeftSegment->point2->x = 0.0;
                        newLeftSegment->point2->y = biggestY;

                        segment_t* newDownSegment = calloc(1, sizeof(segment_t));
                        newDownSegment->point1 = calloc(1, sizeof(point_t));
                        newDownSegment->point2 = calloc(1, sizeof(point_t));

                        newDownSegment->point1->x = wallPointSegPoint2->point2->x;
                        newDownSegment->point1->y = biggestY;
                        newDownSegment->point2->x = 0.0;
                        newDownSegment->point2->y = biggestY;

                        insert(listOfSegmentsShadowPolygon, segment);
                        insert(listOfSegmentsShadowPolygon, wallPointSegPoint1);
                        insert(listOfSegmentsShadowPolygon, wallPointSegPoint2);
                        insert(listOfSegmentsShadowPolygon, newLeftSegment);
                        insert(listOfSegmentsShadowPolygon, newDownSegment);
                    }
                } else if (wallPointSegPoint2->point2->x == 0) {
                    if (wallPointSegPoint1->point2->y == 0 && wallPointSegPoint1->point2->y > 0) {
                        puts("three");
                        ok = 1;
                        segment_t* newLeftSegment = calloc(1, sizeof(segment_t));
                        newLeftSegment->point1 = calloc(1, sizeof(point_t));
                        newLeftSegment->point2 = calloc(1, sizeof(point_t));

                        newLeftSegment->point1->x = 0.0;
                        newLeftSegment->point1->y = wallPointSegPoint2->point2->y;
                        newLeftSegment->point2->x = 0.0;
                        newLeftSegment->point2->y = 0.0;

                        segment_t* newUpSegment = calloc(1, sizeof(segment_t));
                        newUpSegment->point1 = calloc(1, sizeof(point_t));
                        newUpSegment->point2 = calloc(1, sizeof(point_t));

                        newUpSegment->point1->x = wallPointSegPoint1->point2->x;
                        newUpSegment->point1->y = 0.0;
                        newUpSegment->point2->x = 0.0;
                        newUpSegment->point2->y = 0.0;
                        insert(listOfSegmentsShadowPolygon, segment);
                        insert(listOfSegmentsShadowPolygon, wallPointSegPoint1);
                        insert(listOfSegmentsShadowPolygon, wallPointSegPoint2);
                        insert(listOfSegmentsShadowPolygon, newLeftSegment);
                        insert(listOfSegmentsShadowPolygon, newUpSegment);
                    }

                } else if (wallPointSegPoint1->point2->y == 0 && wallPointSegPoint2->point2->y == biggestY) {
                    puts("four");
                    ok = 1;
                    segment_t* newLeftSegment = calloc(1, sizeof(segment_t));
                    newLeftSegment->point1 = calloc(1, sizeof(point_t));
                    newLeftSegment->point2 = calloc(1, sizeof(point_t));

                    newLeftSegment->point1->x = 0.0;
                    newLeftSegment->point1->y = 0.0;
                    newLeftSegment->point2->x = 0.0;
                    newLeftSegment->point2->y = biggestY;

                    segment_t* newUpSegment = calloc(1, sizeof(segment_t));
                    newUpSegment->point1 = calloc(1, sizeof(point_t));
                    newUpSegment->point2 = calloc(1, sizeof(point_t));

                    newUpSegment->point1->x = wallPointSegPoint1->point2->x;
                    newUpSegment->point1->y = 0.0;
                    newUpSegment->point2->x = 0.0;
                    newUpSegment->point2->y = 0.0;

                    segment_t* newDownSegment = calloc(1, sizeof(segment_t));
                    newDownSegment->point1 = calloc(1, sizeof(point_t));
                    newDownSegment->point2 = calloc(1, sizeof(point_t));

                    newDownSegment->point1->x = wallPointSegPoint2->point2->x;
                    newDownSegment->point1->y = biggestY;
                    newDownSegment->point2->x = 0.0;
                    newDownSegment->point2->y = biggestY;

                    insert(listOfSegmentsShadowPolygon, segment);
                    insert(listOfSegmentsShadowPolygon, wallPointSegPoint1);
                    insert(listOfSegmentsShadowPolygon, wallPointSegPoint2);
                    insert(listOfSegmentsShadowPolygon, newLeftSegment);
                    insert(listOfSegmentsShadowPolygon, newUpSegment);
                    insert(listOfSegmentsShadowPolygon, newDownSegment);

                } else if (wallPointSegPoint1->point2->y == 0 && wallPointSegPoint2->point2->y == 0) {
                    puts("five");
                    ok = 1;
                    segment_t* newUpSegment = calloc(1, sizeof(segment_t));
                    newUpSegment->point1 = calloc(1, sizeof(point_t));
                    newUpSegment->point2 = calloc(1, sizeof(point_t));

                    newUpSegment->point1->x = wallPointSegPoint2->point2->x;
                    newUpSegment->point1->y = 0.0;
                    newUpSegment->point2->x = wallPointSegPoint1->point2->x;
                    newUpSegment->point2->y = 0.0;

                    insert(listOfSegmentsShadowPolygon, segment);
                    insert(listOfSegmentsShadowPolygon, wallPointSegPoint1);
                    insert(listOfSegmentsShadowPolygon, wallPointSegPoint2);
                    insert(listOfSegmentsShadowPolygon, newUpSegment);

                } else if (wallPointSegPoint1->point2->y == biggestY && wallPointSegPoint2->point2->y == biggestY) {
                    puts("six");
                    ok = 1;
                    segment_t* newDownSegment = calloc(1, sizeof(segment_t));
                    newDownSegment->point1 = calloc(1, sizeof(point_t));
                    newDownSegment->point2 = calloc(1, sizeof(point_t));

                    newDownSegment->point1->x = wallPointSegPoint1->point2->x;
                    newDownSegment->point1->y = biggestY;
                    newDownSegment->point2->x = wallPointSegPoint2->point2->x;
                    newDownSegment->point2->y = biggestY;

                    insert(listOfSegmentsShadowPolygon, segment);
                    insert(listOfSegmentsShadowPolygon, wallPointSegPoint1);
                    insert(listOfSegmentsShadowPolygon, wallPointSegPoint2);
                    insert(listOfSegmentsShadowPolygon, newDownSegment);
                }

            } else if (segment->point1->x > xMeteor && vertical) {  //The segment is on the right of the bomb and vertical

                if (wallPointSegPoint1->point2->x == biggestX) {
                    if (wallPointSegPoint2->point2->x == biggestX && wallPointSegPoint2->point2->y <= biggestY) {
                        puts("seven");
                        ok = 1;
                        segment_t* newRightSegment = calloc(1, sizeof(segment_t));
                        newRightSegment->point1 = calloc(1, sizeof(point_t));
                        newRightSegment->point2 = calloc(1, sizeof(point_t));

                        newRightSegment->point1->x = biggestX;
                        newRightSegment->point1->y = wallPointSegPoint1->point2->y;
                        newRightSegment->point2->x = biggestX;
                        newRightSegment->point2->y = wallPointSegPoint2->point2->y;

                        insert(listOfSegmentsShadowPolygon, segment);
                        insert(listOfSegmentsShadowPolygon, wallPointSegPoint1);
                        insert(listOfSegmentsShadowPolygon, wallPointSegPoint2);
                        insert(listOfSegmentsShadowPolygon, newRightSegment);
                    } else if (wallPointSegPoint2->point2->x < biggestX && wallPointSegPoint2->point2->y == biggestY && wallPointSegPoint1->point1->y < biggestY) {
                        puts("eight");
                        ok = 1;
                        segment_t* newRightSegment = calloc(1, sizeof(segment_t));
                        newRightSegment->point1 = calloc(1, sizeof(point_t));
                        newRightSegment->point2 = calloc(1, sizeof(point_t));

                        newRightSegment->point1->x = biggestX;
                        newRightSegment->point1->y = wallPointSegPoint1->point2->y;
                        newRightSegment->point2->x = biggestX;
                        newRightSegment->point2->y = biggestY;

                        segment_t* newDownSegment = calloc(1, sizeof(segment_t));
                        newDownSegment->point1 = calloc(1, sizeof(point_t));
                        newDownSegment->point2 = calloc(1, sizeof(point_t));

                        newDownSegment->point1->x = wallPointSegPoint2->point2->x;
                        newDownSegment->point1->y = biggestY;
                        newDownSegment->point2->x = biggestX;
                        newDownSegment->point2->y = biggestY;

                        insert(listOfSegmentsShadowPolygon, segment);
                        insert(listOfSegmentsShadowPolygon, wallPointSegPoint1);
                        insert(listOfSegmentsShadowPolygon, wallPointSegPoint2);
                        insert(listOfSegmentsShadowPolygon, newRightSegment);
                        insert(listOfSegmentsShadowPolygon, newDownSegment);
                    }

                } else if (wallPointSegPoint2->point2->x == biggestX && wallPointSegPoint2->point2->y > 0) {
                    if (wallPointSegPoint1->point2->y == 0) {
                        puts("nine");
                        ok = 1;
                        segment_t* newRightSegment = calloc(1, sizeof(segment_t));
                        newRightSegment->point1 = calloc(1, sizeof(point_t));
                        newRightSegment->point2 = calloc(1, sizeof(point_t));

                        newRightSegment->point1->x = biggestX;
                        newRightSegment->point1->y = wallPointSegPoint2->point2->y;
                        newRightSegment->point2->x = biggestX;
                        newRightSegment->point2->y = 0.0;

                        segment_t* newUpSegment = calloc(1, sizeof(segment_t));
                        newUpSegment->point1 = calloc(1, sizeof(point_t));
                        newUpSegment->point2 = calloc(1, sizeof(point_t));

                        newUpSegment->point1->x = wallPointSegPoint1->point2->x;
                        newUpSegment->point1->y = 0.0;
                        newUpSegment->point2->x = biggestX;
                        newUpSegment->point2->y = 0.0;

                        insert(listOfSegmentsShadowPolygon, segment);
                        insert(listOfSegmentsShadowPolygon, wallPointSegPoint1);
                        insert(listOfSegmentsShadowPolygon, wallPointSegPoint2);
                        insert(listOfSegmentsShadowPolygon, newUpSegment);
                        insert(listOfSegmentsShadowPolygon, newUpSegment);
                    }

                } else if (wallPointSegPoint1->point2->y == 0 && wallPointSegPoint2->point2->y == biggestY) {
                    puts("ten");
                    ok = 1;
                    segment_t* newRightSegment = calloc(1, sizeof(segment_t));
                    newRightSegment->point1 = calloc(1, sizeof(point_t));
                    newRightSegment->point2 = calloc(1, sizeof(point_t));

                    newRightSegment->point1->x = biggestX;
                    newRightSegment->point1->y = 0.0;
                    newRightSegment->point2->x = biggestX;
                    newRightSegment->point2->y = biggestY;

                    segment_t* newUpSegment = calloc(1, sizeof(segment_t));
                    newUpSegment->point1 = calloc(1, sizeof(point_t));
                    newUpSegment->point2 = calloc(1, sizeof(point_t));

                    newUpSegment->point1->x = wallPointSegPoint1->point2->x;
                    newUpSegment->point1->y = 0.0;
                    newUpSegment->point2->x = biggestX;
                    newUpSegment->point2->y = 0.0;

                    segment_t* newDownSegment = calloc(1, sizeof(segment_t));
                    newDownSegment->point1 = calloc(1, sizeof(point_t));
                    newDownSegment->point2 = calloc(1, sizeof(point_t));

                    newDownSegment->point1->x = wallPointSegPoint2->point2->x;
                    newDownSegment->point1->y = biggestY;
                    newDownSegment->point2->x = 0.0;
                    newDownSegment->point2->y = biggestY;

                    insert(listOfSegmentsShadowPolygon, segment);
                    insert(listOfSegmentsShadowPolygon, wallPointSegPoint1);
                    insert(listOfSegmentsShadowPolygon, wallPointSegPoint2);
                    insert(listOfSegmentsShadowPolygon, newRightSegment);
                    insert(listOfSegmentsShadowPolygon, newUpSegment);
                    insert(listOfSegmentsShadowPolygon, newDownSegment);

                } else if (wallPointSegPoint1->point2->y == 0 && wallPointSegPoint2->point2->y == 0) {
                    puts("eleven");
                    ok = 1;
                    segment_t* newUpSegment = calloc(1, sizeof(segment_t));
                    newUpSegment->point1 = calloc(1, sizeof(point_t));
                    newUpSegment->point2 = calloc(1, sizeof(point_t));

                    newUpSegment->point1->x = wallPointSegPoint1->point2->x;
                    newUpSegment->point1->y = 0.0;
                    newUpSegment->point2->x = wallPointSegPoint2->point2->x;
                    newUpSegment->point2->y = 0.0;

                    insert(listOfSegmentsShadowPolygon, segment);
                    insert(listOfSegmentsShadowPolygon, wallPointSegPoint1);
                    insert(listOfSegmentsShadowPolygon, wallPointSegPoint2);
                    insert(listOfSegmentsShadowPolygon, newUpSegment);

                } else if (wallPointSegPoint1->point2->y == biggestY && wallPointSegPoint2->point2->y == biggestY) {
                    puts("twelve");
                    ok = 1;
                    segment_t* newDownSegment = calloc(1, sizeof(segment_t));
                    newDownSegment->point1 = calloc(1, sizeof(point_t));
                    newDownSegment->point2 = calloc(1, sizeof(point_t));

                    newDownSegment->point1->x = wallPointSegPoint2->point2->x;
                    newDownSegment->point1->y = biggestY;
                    newDownSegment->point2->x = wallPointSegPoint1->point2->x;
                    newDownSegment->point2->y = biggestY;

                    insert(listOfSegmentsShadowPolygon, segment);
                    insert(listOfSegmentsShadowPolygon, wallPointSegPoint1);
                    insert(listOfSegmentsShadowPolygon, wallPointSegPoint2);
                    insert(listOfSegmentsShadowPolygon, newDownSegment);
                }

            } else if (segment->point1->y > yMeteor && horizontal) {
                if (wallPointSegPoint1->point2->y == biggestY && wallPointSegPoint2->point2->y == biggestY) {
                    puts("thirteen");
                    ok = 1;
                    segment_t* newDownSegment = calloc(1, sizeof(segment_t));
                    newDownSegment->point1 = calloc(1, sizeof(point_t));
                    newDownSegment->point2 = calloc(1, sizeof(point_t));

                    newDownSegment->point1->x = wallPointSegPoint1->point2->x;
                    newDownSegment->point1->y = biggestY;
                    newDownSegment->point2->x = wallPointSegPoint2->point2->x;
                    newDownSegment->point2->y = biggestY;

                    insert(listOfSegmentsShadowPolygon, segment);
                    insert(listOfSegmentsShadowPolygon, wallPointSegPoint1);
                    insert(listOfSegmentsShadowPolygon, wallPointSegPoint2);
                    insert(listOfSegmentsShadowPolygon, newDownSegment);

                } else if (wallPointSegPoint1->point2->x == 0 && wallPointSegPoint2->point2->y == biggestY && wallPointSegPoint2->point2->x > 0) {
                    puts("fourteen");
                    ok = 1;

                    segment_t* newDownSegment = calloc(1, sizeof(segment_t));
                    newDownSegment->point1 = calloc(1, sizeof(point_t));
                    newDownSegment->point2 = calloc(1, sizeof(point_t));

                    newDownSegment->point1->x = wallPointSegPoint2->point2->x;
                    newDownSegment->point1->y = biggestY;
                    newDownSegment->point2->x = 0.0;
                    newDownSegment->point2->y = biggestY;

                    segment_t* newLeftSegment = calloc(1, sizeof(segment_t));
                    newLeftSegment->point1 = calloc(1, sizeof(point_t));
                    newLeftSegment->point2 = calloc(1, sizeof(point_t));

                    newLeftSegment->point1->x = 0.0;
                    newLeftSegment->point1->y = wallPointSegPoint1->point2->y;
                    newLeftSegment->point2->x = 0.0;
                    newLeftSegment->point2->y = biggestY;

                    insert(listOfSegmentsShadowPolygon, segment);
                    insert(listOfSegmentsShadowPolygon, wallPointSegPoint1);
                    insert(listOfSegmentsShadowPolygon, wallPointSegPoint2);
                    insert(listOfSegmentsShadowPolygon, newDownSegment);
                    insert(listOfSegmentsShadowPolygon, newLeftSegment);

                } else if (wallPointSegPoint2->point2->x == biggestX && wallPointSegPoint1->point2->y == biggestY && wallPointSegPoint1->point2->x < biggestX) {
                    puts("fifteen");
                    ok = 1;
                    segment_t* newDownSegment = calloc(1, sizeof(segment_t));
                    newDownSegment->point1 = calloc(1, sizeof(point_t));
                    newDownSegment->point2 = calloc(1, sizeof(point_t));

                    newDownSegment->point1->x = wallPointSegPoint1->point2->x;
                    newDownSegment->point1->y = biggestY;
                    newDownSegment->point2->x = biggestX;
                    newDownSegment->point2->y = biggestY;

                    segment_t* newRightSegment = calloc(1, sizeof(segment_t));
                    newRightSegment->point1 = calloc(1, sizeof(point_t));
                    newRightSegment->point2 = calloc(1, sizeof(point_t));

                    newRightSegment->point1->x = biggestX;
                    newRightSegment->point1->y = wallPointSegPoint2->point2->y;
                    newRightSegment->point2->x = biggestX;
                    newRightSegment->point2->y = biggestY;

                    insert(listOfSegmentsShadowPolygon, segment);
                    insert(listOfSegmentsShadowPolygon, wallPointSegPoint1);
                    insert(listOfSegmentsShadowPolygon, wallPointSegPoint2);
                    insert(listOfSegmentsShadowPolygon, newDownSegment);
                    insert(listOfSegmentsShadowPolygon, newRightSegment);

                } else if (wallPointSegPoint1->point2->x == 0.0 && wallPointSegPoint2->point2->x == biggestX && wallPointSegPoint1->point2->y < biggestY && wallPointSegPoint2->point2->y < biggestY) {
                    puts("sixteen");
                    ok = 1;
                    segment_t* newDownSegment = calloc(1, sizeof(segment_t));
                    newDownSegment->point1 = calloc(1, sizeof(point_t));
                    newDownSegment->point2 = calloc(1, sizeof(point_t));

                    newDownSegment->point1->x = 0.0;
                    newDownSegment->point1->y = biggestY;
                    newDownSegment->point2->x = biggestX;
                    newDownSegment->point2->y = biggestY;

                    segment_t* newRightSegment = calloc(1, sizeof(segment_t));
                    newRightSegment->point1 = calloc(1, sizeof(point_t));
                    newRightSegment->point2 = calloc(1, sizeof(point_t));

                    newRightSegment->point1->x = biggestX;
                    newRightSegment->point1->y = wallPointSegPoint2->point2->y;
                    newRightSegment->point2->x = biggestX;
                    newRightSegment->point2->y = biggestY;

                    segment_t* newLeftSegment = calloc(1, sizeof(segment_t));
                    newLeftSegment->point1 = calloc(1, sizeof(point_t));
                    newLeftSegment->point2 = calloc(1, sizeof(point_t));

                    newLeftSegment->point1->x = 0.0;
                    newLeftSegment->point1->y = wallPointSegPoint1->point2->y;
                    newLeftSegment->point2->x = 0.0;
                    newLeftSegment->point2->y = biggestY;

                    insert(listOfSegmentsShadowPolygon, segment);
                    insert(listOfSegmentsShadowPolygon, wallPointSegPoint1);
                    insert(listOfSegmentsShadowPolygon, wallPointSegPoint2);
                    insert(listOfSegmentsShadowPolygon, newDownSegment);
                    insert(listOfSegmentsShadowPolygon, newLeftSegment);
                    insert(listOfSegmentsShadowPolygon, newRightSegment);


                } else if (wallPointSegPoint1->point2->x == 0.0 && wallPointSegPoint2->point2->x == 0.0) {
                    puts("seventeen");
                    ok = 1;
                    segment_t* newLeftSegment = calloc(1, sizeof(segment_t));
                    newLeftSegment->point1 = calloc(1, sizeof(point_t));
                    newLeftSegment->point2 = calloc(1, sizeof(point_t));

                    newLeftSegment->point1->x = 0.0;
                    newLeftSegment->point1->y = wallPointSegPoint1->point2->y;
                    newLeftSegment->point2->x = 0.0;
                    newLeftSegment->point2->y = wallPointSegPoint2->point2->y;

                    insert(listOfSegmentsShadowPolygon, segment);
                    insert(listOfSegmentsShadowPolygon, wallPointSegPoint1);
                    insert(listOfSegmentsShadowPolygon, wallPointSegPoint2);
                    insert(listOfSegmentsShadowPolygon, newLeftSegment);
                    

                } else if (wallPointSegPoint1->point2->x == biggestX && wallPointSegPoint2->point2->x == biggestX) {
                    puts("eighteen");
                    ok = 1;
                    segment_t* newRightSegment = calloc(1, sizeof(segment_t));
                    newRightSegment->point1 = calloc(1, sizeof(point_t));
                    newRightSegment->point2 = calloc(1, sizeof(point_t));

                    newRightSegment->point1->x = biggestX;
                    newRightSegment->point1->y = wallPointSegPoint1->point2->y;
                    newRightSegment->point2->x = biggestX;
                    newRightSegment->point2->y = wallPointSegPoint2->point2->y;

                    insert(listOfSegmentsShadowPolygon, segment);
                    insert(listOfSegmentsShadowPolygon, wallPointSegPoint1);
                    insert(listOfSegmentsShadowPolygon, wallPointSegPoint2);
                    insert(listOfSegmentsShadowPolygon, newRightSegment);
                }

            } else if (segment->point1->y < yMeteor && horizontal) {
                if (wallPointSegPoint1->point2->y == 0.0 && wallPointSegPoint2->point2->y == 0.0) {
                    puts("nineteen");
                    ok = 1;
                    segment_t* newUpSegment = calloc(1, sizeof(segment_t));
                    newUpSegment->point1 = calloc(1, sizeof(point_t));
                    newUpSegment->point2 = calloc(1, sizeof(point_t));

                    newUpSegment->point1->x = wallPointSegPoint1->point2->x;
                    newUpSegment->point1->y = 0.0;
                    newUpSegment->point2->x = wallPointSegPoint2->point2->x;
                    newUpSegment->point2->y = 0.0;

                    insert(listOfSegmentsShadowPolygon, segment);
                    insert(listOfSegmentsShadowPolygon, wallPointSegPoint1);
                    insert(listOfSegmentsShadowPolygon, wallPointSegPoint2);
                    insert(listOfSegmentsShadowPolygon, newUpSegment);
                }else if(wallPointSegPoint1->point2->x == 0 && wallPointSegPoint2->point2->y == 0.0 && wallPointSegPoint2->point2->x > 0){
                    puts("twenty");
                    ok = 1;
                    segment_t* newUpSegment = calloc(1, sizeof(segment_t));
                    newUpSegment->point1 = calloc(1, sizeof(point_t));
                    newUpSegment->point2 = calloc(1, sizeof(point_t));

                    newUpSegment->point1->x = wallPointSegPoint2->point2->x;
                    newUpSegment->point1->y = 0.0;
                    newUpSegment->point2->x = 0.0;
                    newUpSegment->point2->y = 0.0;

                    segment_t* newLeftSegment = calloc(1, sizeof(segment_t));
                    newLeftSegment->point1 = calloc(1, sizeof(point_t));
                    newLeftSegment->point2 = calloc(1, sizeof(point_t));

                    newLeftSegment->point1->x = 0.0;
                    newLeftSegment->point1->y = wallPointSegPoint1->point2->y;
                    newLeftSegment->point2->x = 0.0;
                    newLeftSegment->point2->y = 0.0;

                    insert(listOfSegmentsShadowPolygon, segment);
                    insert(listOfSegmentsShadowPolygon, wallPointSegPoint1);
                    insert(listOfSegmentsShadowPolygon, wallPointSegPoint2);
                    insert(listOfSegmentsShadowPolygon, newLeftSegment);
                }else if(wallPointSegPoint2->point2->x == biggestX && wallPointSegPoint1->point2->y == 0.0 && wallPointSegPoint1->point2->x < biggestX){
                    puts("twenty-one");
                    ok = 1;

                    segment_t* newRightSegment = calloc(1, sizeof(segment_t));
                    newRightSegment->point1 = calloc(1, sizeof(point_t));
                    newRightSegment->point2 = calloc(1, sizeof(point_t));

                    newRightSegment->point1->x = biggestX;
                    newRightSegment->point1->y = wallPointSegPoint2->point2->y;
                    newRightSegment->point2->x = biggestX;
                    newRightSegment->point2->y = 0.0;

                    segment_t* newUpSegment = calloc(1, sizeof(segment_t));
                    newUpSegment->point1 = calloc(1, sizeof(point_t));
                    newUpSegment->point2 = calloc(1, sizeof(point_t));

                    newUpSegment->point1->x = wallPointSegPoint1->point2->x;
                    newUpSegment->point1->y = 0.0;
                    newUpSegment->point2->x = biggestX;
                    newUpSegment->point2->y = 0.0;

                    insert(listOfSegmentsShadowPolygon, segment);
                    insert(listOfSegmentsShadowPolygon, wallPointSegPoint1);
                    insert(listOfSegmentsShadowPolygon, wallPointSegPoint2);
                    insert(listOfSegmentsShadowPolygon, newRightSegment);
                    insert(listOfSegmentsShadowPolygon, newUpSegment);
                }else if(wallPointSegPoint1->point2->x == 0.0 && wallPointSegPoint2->point2->x == biggestX && wallPointSegPoint1->point2->y > 0 && wallPointSegPoint2->point2->y > 0){
                    puts("twenty-two");
                    ok = 1;

                    segment_t* newLeftSegment = calloc(1, sizeof(segment_t));
                    newLeftSegment->point1 = calloc(1, sizeof(point_t));
                    newLeftSegment->point2 = calloc(1, sizeof(point_t));

                    newLeftSegment->point1->x = 0.0;
                    newLeftSegment->point1->y = wallPointSegPoint1->point2->y;
                    newLeftSegment->point2->x = 0.0;
                    newLeftSegment->point2->y = 0.0;

                    segment_t* newRightSegment = calloc(1, sizeof(segment_t));
                    newRightSegment->point1 = calloc(1, sizeof(point_t));
                    newRightSegment->point2 = calloc(1, sizeof(point_t));

                    newRightSegment->point1->x = biggestX;
                    newRightSegment->point1->y = wallPointSegPoint2->point2->y;
                    newRightSegment->point2->x = biggestX;
                    newRightSegment->point2->y = 0.0;

                    segment_t* newUpSegment = calloc(1, sizeof(segment_t));
                    newUpSegment->point1 = calloc(1, sizeof(point_t));
                    newUpSegment->point2 = calloc(1, sizeof(point_t));

                    newUpSegment->point1->x = 0.0;
                    newUpSegment->point1->y = 0.0;
                    newUpSegment->point2->x = biggestX;
                    newUpSegment->point2->y = 0.0;

                    insert(listOfSegmentsShadowPolygon, segment);
                    insert(listOfSegmentsShadowPolygon, wallPointSegPoint1);
                    insert(listOfSegmentsShadowPolygon, wallPointSegPoint2);
                    insert(listOfSegmentsShadowPolygon, newLeftSegment);
                    insert(listOfSegmentsShadowPolygon, newRightSegment);
                    insert(listOfSegmentsShadowPolygon, newUpSegment);
                } else if (wallPointSegPoint1->point2->x == 0.0 && wallPointSegPoint2->point2->x == 0.0) {
                    puts("twenty-three");
                    ok = 1;
                    segment_t* newLeftSegment = calloc(1, sizeof(segment_t));
                    newLeftSegment->point1 = calloc(1, sizeof(point_t));
                    newLeftSegment->point2 = calloc(1, sizeof(point_t));

                    newLeftSegment->point1->x = 0.0;
                    newLeftSegment->point1->y = wallPointSegPoint1->point2->y;
                    newLeftSegment->point2->x = 0.0;
                    newLeftSegment->point2->y = wallPointSegPoint2->point2->y;

                    insert(listOfSegmentsShadowPolygon, segment);
                    insert(listOfSegmentsShadowPolygon, wallPointSegPoint1);
                    insert(listOfSegmentsShadowPolygon, wallPointSegPoint2);
                    insert(listOfSegmentsShadowPolygon, newLeftSegment);

                } else if (wallPointSegPoint1->point2->x == biggestX && wallPointSegPoint2->point2->x == biggestX) {
                    puts("twenty-four");
                    ok = 1;
                    segment_t* newRightSegment = calloc(1, sizeof(segment_t));
                    newRightSegment->point1 = calloc(1, sizeof(point_t));
                    newRightSegment->point2 = calloc(1, sizeof(point_t));

                    newRightSegment->point1->x = biggestX;
                    newRightSegment->point1->y = wallPointSegPoint1->point2->y;
                    newRightSegment->point2->x = biggestX;
                    newRightSegment->point2->y = wallPointSegPoint2->point2->y;

                    insert(listOfSegmentsShadowPolygon, segment);
                    insert(listOfSegmentsShadowPolygon, wallPointSegPoint1);
                    insert(listOfSegmentsShadowPolygon, wallPointSegPoint2);
                    insert(listOfSegmentsShadowPolygon, newRightSegment);

                }
            }
            void* shadowRoot = NTgetRootNode(shadowPolygons);
            if (!shadowRoot) {
                shadowRoot = NTinsertShadow(shadowPolygons, shadowRoot, shadowRoot, listOfSegmentsShadowPolygon);
            } else {
                NTinsertShadow(shadowPolygons, shadowRoot, shadowRoot, listOfSegmentsShadowPolygon);
            }

            if(!ok){
                puts("\n==============faltou alguma condicional==============\n");
            }else{
                puts("********************");
            }
            
        }
    }

    free(extremes);
}
*/